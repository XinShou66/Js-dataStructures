<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>0322-零钱兑换</title>
</head>
<body>
<script>
   /*给定不同面额的硬币 coins 和一个总金额 amount。
   编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
    你可以认为每种硬币的数量是无限的。*/

    /*方法1：动态规划*/
    /**
     * 假设给出的不同面额的硬币是[1, 2, 5]，目标是 120，问最少需要的硬币个数？
     dp[i]: 表示总金额为 i 的时候最优解法的硬币数

     - 我们想一下：求总金额 120 有几种方法？下面这个思路关键了 !!!
     一共有 3 种方式，因为我们有 3 种不同面值的硬币。

     1.拿一枚面值为 1 的硬币 + 总金额为 119 的最优解法的硬币数量
     这里我们只需要假设总金额为 119 的最优解法的硬币数有人已经帮我们算好了，
     不需要纠结于此。(虽然一会也是我们自己算，哈哈)
     即：dp[119] + 1

     2.拿一枚面值为 2 的硬币 + 总金额为 118 的最优解法的硬币数
     这里我们只需要假设总金额为 118 的最优解法的硬币数有人已经帮我们算好了
     即：dp[118] + 1

     3.拿一枚面值为 5 的硬币 + 总金额为 115 的最优解法的硬币数
     这里我们只需要假设总金额为 115 的最优解法的硬币数有人已经帮我们算好了
     即：dp[115] + 1

     - 所以，总金额为 120 的最优解法就是上面这三种解法中最优的一种，也就是硬币数最少
     的一种，我们下面试着用代码来表示一下：

     - dp[120] = Math.min(dp[119] + 1, dp[118] + 1, dp[115] + 1);

     - 推导出「状态转移方程」：
     dp[i] = Math.min(dp[i - coin] + 1, dp[i - coin] + 1, ...)
     其中 coin 有多少种可能，我们就需要比较多少次，那么我们到底需要比较多少次呢？
     当然是 coins 数组中有几种不同面值的硬币，就是多少次了~ 遍历 coins 数组，
     分别去对比即可。
    * */

   /**
    * @param {number[]} coins
    * @param {number} amount
    * @return {number}
    */
   var coinChange = function(coins, amount) {
       let dp = new Array(amount + 1).fill(Infinity);
       dp[0] = 0;

       for (let i = 1; i <= amount; i++) {
           for (let coin of coins) {
               if (i - coin >= 0) {
                   //dp[i]: 表示总金额为 i 的时候最优解法的硬币数
                   dp[i] = Math.min(dp[i], dp[i - coin] + 1);
               }
           }
       }

       return dp[amount] === Infinity ? -1 : dp[amount];

   };

   //运行结果：运行时间击败54.50%(144ms)，内存消耗击败47.09%(42.9mb)




</script>
</body>
</html>