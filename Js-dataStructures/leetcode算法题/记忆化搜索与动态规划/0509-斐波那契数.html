<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>斐波那契数</title>
</head>
<body>
<script>
    /************************ 与剑指offer中 010-1-斐波那契数列 解法相同 *****************************/

    /*斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。
    该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
        F(0) = 0，F(1) = 1
        F(n) = F(n - 1) + F(n - 2)，其中 n > 1
     给你 n ，请计算 F(n) 。*/

    /*方法1：迭代*/
    /****************注意要对计算的数据取模*****************/


    /**
     * @param {number} n
     * @return {number}
     */
    var fib = function(n) {
        if (n < 2) {
            return n;
        }
        let fib0 = 0;
        let fib1 = 1;
        let fibn;
        for (let i = 2; i <= n; i++) { // n >= 2
            fibn = fib1 + fib0; //f(n) = f(n-1) + f(n-2)
            fib0 = fib1; //要先更新fib0的值，再更新fib1的值
            fib1 = fibn;
        }
        return fibn;
    };


    //运行结果：运行时间击败91.25%(76ms)，内存消耗击败56.10%(37.6mb)


    /************************ 剑指中会超时 **********************/
    /*方法2: 记忆化递归*/

    /**
     * @param {number} n
     * @return {number}
     */
    var fib = function(n) {
        let map = new Map();
        if (map.has(n)) {
            return map.get(n);
        }
        let res;
        if (n < 2) {
            res = n;
        } else {
            res = fib(n - 1) + fib(n - 2);
        }
        map.set(n, res);
        return res;
    };
    //运行结果：运行时间击败5.49%(400ms)，内存消耗击败5.08%(43.2mb)


    /************************ 剑指中会超时 **********************/
    /*方法3：递归*/
    //递归写法，运行有时会超时（剑指offer中），应用迭代写法
    var fib = function(n) {
        if (n < 2) {
            return n;
        } else {
            return fib(n - 1) + fib(n - 2);
        }
    };
    //运行结果：运行时间击败26.25%(108ms)，内存消耗击败36.41%(37.7mb)

</script>
</body>
</html>