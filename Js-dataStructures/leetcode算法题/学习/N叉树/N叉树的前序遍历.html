<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>N叉树的前序遍历</title>
</head>
<body>
<script>
    /*给定一个 N 叉树，返回其节点值的 前序遍历 。
    N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
    进阶：
        递归法很简单，你可以使用迭代法完成此题吗?*/


    /********************************************* 方法1：递归 *********************************************/

    /**
     * // Definition for a Node.
     * function Node(val, children) {
     *    this.val = val;
     *    this.children = children;
     * };
     */

    /**
     * @param {Node} root
     * @return {number[]}
     */
    var preorder = function(root) {
        let res = [];
        function preorderTraversal(node) {
            if (node) {
                res.push(node.val);
                for (let v of node.children) {
                    preorderTraversal(v);
                }
            }
        }
        preorderTraversal(root);

        return res;
    };

    //运行结果：运行时间击败66.29%(108ms)，内存消耗击败48.91%(41.1mb)

    /********************************************* 方法2：迭代 *********************************************/

    /**
     * // Definition for a Node.
     * function Node(val, children) {
     *    this.val = val;
     *    this.children = children;
     * };
     */

    /**
     * @param {Node} root
     * @return {number[]}
     */
    var preorder = function(root) {
        let res = [];
        let stack = [];
        if (root) stack.push(root);
        while (stack.length) {
            let cur = stack.pop();
            //第一步，先访问根节点
            res.push(cur.val);
            //第二步，处理孩子节点
            //栈的后进先出原则与给定的是层序遍历的序列化
            for (let i = cur.children.length - 1; i >= 0; i--) {
                stack.push(cur.children[i])
            }
        }

        return res;
    };

    //运行结果：运行时间击败66.29%(108ms)，内存消耗击败48.91%(41.1mb)

</script>
</body>
</html>