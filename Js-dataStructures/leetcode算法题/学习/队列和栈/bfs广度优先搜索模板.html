<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>bfs</title>
</head>
<body>
<script>
    /*模板Ⅰ*/
    function  bfs(root,target) {
        let queue = [];//存储等待处理的所有节点
        let step = 0; //从根节点到当前节点所需的步骤数
        // 初始化
        queue.push(root);
        // BFS
        while (queue.length > 0) {
            step = step + 1;//有时for要在循环后加？
            let length = queue.length;//注意一定要在循环开始前重新获取
            //迭代已经在队列中的节点
            for (let i = 0; i < length; i++) {
                let cur = queue.shift();
                if (cur == target) {
                    return step;
                }
                //对节点的邻居进行处理
                if (node.left){
                    let left = root.left;
                    queue.push(left);
                }
                if (node.right){
                    let rifgt = root.right;
                    queue.push(rifgt);
                }


            }
        }
        return -1;          //从根到目标没有路径
    }

    /*模板Ⅱ*/
    /*有时，确保我们永远不会访问一个结点两次很重要。否则，我们可能陷入无限循环。
    如果是这样，我们可以在上面的代码中添加一个哈希集来解决这个问题。
    这是修改后的伪代码：*/
    function  bfs(root,target) {
        let queue = [];//存储等待处理的所有节点
        let used = new Set()//存储所有使用过的节点
        let step = 0; //从根节点到当前节点所需的步骤数
        // 初始化
        queue.push(root);
        used.add(root);
        // BFS
        while (queue.length > 0) {
            step = step + 1;//有时for要在循环后加？
            let length = queue.length;//注意一定要在循环开始前重新获取
            //迭代已经在队列中的节点
            for (let i = 0; i < length; i++) {
                let cur = queue.shift();
                if (cur == target) {
                    return step;
                }
                //对节点的邻居进行处理
                let left = root.left;
                let right = root.right;
                if (!used.has(left)) {
                    queue.push(left);
                    used.add(left);
                }
                if (!used.has(right)) {
                    queue.push(right);
                    used.add(right);
                }

            }
        }
        return -1;          //从根到目标没有路径
    }

    /********************************原版Java参考*********************************************/

    /**
     * Return the length of the shortest path between root and target node.
     */
    int BFS(Node root, Node target) {
        Queue<Node> queue;  //存储等待处理的所有节点
        int step = 0;       //从根节点到当前节点所需的步骤数
        // 初始化
        add root to queue;
        // BFS
        while (queue is not empty) {
            step = step + 1;
            //迭代已经在队列中的节点
            int size = queue.size();
            for (int i = 0; i < size; ++i) {
                Node cur = the first node in queue;
                return step if cur is target;
                for (Node next : the neighbors of cur) {//the neighbors of的邻居
                    add next to queue;
                }
                remove the first node from queue;
            }
        }
        return -1;          //从根到目标没有路径
    }


    /**
     * Return the length of the shortest path between root and target node.
     */
    int BFS(Node root, Node target) {
        Queue<Node> queue;  //存储等待处理的所有节点
        Set<Node> used;     //存储所有使用的节点
        int step = 0;       //从根节点到当前节点所需的步骤数
        // 初始化
        add root to queue;
        add root to used;
        // BFS
        while (queue is not empty) {
            step = step + 1;
            // 迭代已经在队列中的节点
            int size = queue.size();
            for (int i = 0; i < size; ++i) {
                Node cur = the first node in queue;
                return step if cur is target;
                for (Node next : the neighbors of cur) {
                    if (next is not in used) {
                        add next to queue;
                        add next to used;
                    }
                }
                remove the first node from queue;
            }
        }
        return -1;          //从根到目标没有路径
    }
</script>
</body>
</html>